<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title> Land Area Calculator</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #f5f5f5;
    }
    #header {
      background: linear-gradient(135deg, #2c3e50, #34495e);
      color: white;
      padding: 15px;
      text-align: center;
    }
    #header h1 {
      margin: 0;
      font-size: 24px;
    }
    #header p {
      margin: 5px 0 0 0;
      opacity: 0.9;
      font-size: 14px;
    }
    #map {
      height: 60vh;
      width: 100%;
    }
    #controls {
      padding: 15px;
      background: white;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #controls button {
      padding: 12px 20px;
      margin: 5px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
    }
    #startBtn {
      background: linear-gradient(135deg, #27ae60, #2ecc71);
      color: white;
    }
    #stopBtn {
      background: linear-gradient(135deg, #f39c12, #e67e22);
      color: white;
    }
    #closeBtn {
      background: linear-gradient(135deg, #3498db, #2980b9);
      color: white;
    }
    #clearBtn {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: white;
    }
    #controls button:disabled {
      background: #bdc3c7;
      cursor: not-allowed;
      opacity: 0.6;
    }
    #controls button:not(:disabled):hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    #info {
      padding: 20px;
      background: white;
      margin: 10px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .metric-row {
      display: flex;
      justify-content: space-between;
      margin: 10px 0;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #3498db;
    }
    .metric-label {
      font-weight: bold;
      color: #2c3e50;
    }
    .metric-value {
      font-size: 18px;
      color: #27ae60;
      font-weight: bold;
    }
    #status {
      margin-top: 15px;
      padding: 10px;
      background: #ecf0f1;
      border-radius: 8px;
      font-size: 14px;
      color: #2c3e50;
    }
    .status-good { background: #d5f4e6; color: #27ae60; }
    .status-warning { background: #ffeaa7; color: #d63031; }
    #instructions {
      margin: 10px;
      padding: 15px;
      background: #e8f5e8;
      border-radius: 8px;
      border-left: 4px solid #27ae60;
    }
    .point-tooltip {
      background: white;
      border: 2px solid #27ae60;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
      font-weight: bold;
      color: #27ae60;
    }
    .start-tooltip {
      background: #e74c3c;
      border: 2px solid #c0392b;
      border-radius: 4px;
      padding: 3px 8px;
      font-size: 11px;
      font-weight: bold;
      color: white;
    }
  </style>
</head>
<body>

  <div id="header">
    <h1>üåç Smart Land Area Calculator</h1>
    <p>Just walk around your land - we handle all the technical stuff!</p>
  </div>

  <div id="instructions">
    <strong>üìã How to use:</strong><br>
    1Ô∏è‚É£ Click "Start Walking" and begin at any corner<br>
    2Ô∏è‚É£ Walk around your property boundary<br>
    3Ô∏è‚É£ Click "Stop & Calculate" or "Close Shape" when done<br>
    <small>üí° The app automatically optimizes for accuracy!</small>
  </div>

  <div id="controls">
    <button id="startBtn">üö∂‚Äç‚ôÇÔ∏è Start Walking</button>
    <button id="stopBtn" disabled>‚èπÔ∏è Stop & Calculate</button>
    <button id="closeBtn" disabled>üîó Close Shape</button>
    <button id="clearBtn">üóëÔ∏è Clear & Restart</button>
  </div>

  <div id="map"></div>

  <div id="info">
    <div class="metric-row">
      <span class="metric-label">üìè Area (Square Meters)</span>
      <span class="metric-value" id="areaSqm">0</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">üè° Area (Acres)</span>
      <span class="metric-value" id="areaAcres">0</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">üåæ Area (Hectares)</span>
      <span class="metric-value" id="areaHectares">0</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">üîÑ Perimeter</span>
      <span class="metric-value"><span id="perimeter">0</span> m / <span id="perimeterKm">0</span> km</span>
    </div>
    <div id="status">üéØ Ready to start measuring your land</div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>

  <script>
    const map = L.map('map').setView([20, 77], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '¬© OpenStreetMap contributors'
    }).addTo(map);

    let pathPoints = [];
    let polylineLayer = null;
    let polygonLayer = null;
    let watchId = null;
    let isTracking = false;
    let lastAddedPoint = null;
    let currentLocationMarker = null;
    let pointMarkers = [];
    let totalDistance = 0;
    let startTime = null;
    let firstLocation = true;

    // Simplified thresholds for better reliability
    const MIN_DISTANCE = 3; // meters
    const MAX_ACCURACY = 20; // meters

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const closeBtn = document.getElementById('closeBtn');
    const clearBtn = document.getElementById('clearBtn');
    const areaSqmDisplay = document.getElementById('areaSqm');
    const areaAcresDisplay = document.getElementById('areaAcres');
    const areaHectaresDisplay = document.getElementById('areaHectares');
    const perimeterDisplay = document.getElementById('perimeter');
    const perimeterKmDisplay = document.getElementById('perimeterKm');
    const statusDisplay = document.getElementById('status');

    function getDistance(lat1, lng1, lat2, lng2) {
      const R = 6371e3; // Earth's radius in meters
      const œÜ1 = lat1 * Math.PI/180;
      const œÜ2 = lat2 * Math.PI/180;
      const ŒîœÜ = (lat2-lat1) * Math.PI/180;
      const ŒîŒª = (lng2-lng1) * Math.PI/180;

      const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                Math.cos(œÜ1) * Math.cos(œÜ2) *
                Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

      return R * c;
    }

    function updateStatus() {
      const timeElapsed = startTime ? Math.floor((Date.now() - startTime) / 1000) : 0;
      const minutes = Math.floor(timeElapsed / 60);
      const seconds = timeElapsed % 60;
      
      let statusText = '';
      let statusClass = '';

      if (isTracking) {
        statusText = `üü¢ Walking: ${minutes}:${seconds.toString().padStart(2, '0')} | Points: ${pathPoints.length} | Distance: ${totalDistance.toFixed(0)}m`;
        statusClass = 'status-good';
      } else if (pathPoints.length > 0) {
        statusText = `‚úÖ Measurement complete! Total points: ${pathPoints.length} | Boundary: ${totalDistance.toFixed(0)}m`;
        statusClass = 'status-good';
      } else {
        statusText = 'üéØ Ready to start measuring your land';
        statusClass = '';
      }

      statusDisplay.innerHTML = statusText;
      statusDisplay.className = statusClass;
    }

    function updateCurrentLocation(latlng, accuracy) {
      // Remove previous current location marker
      if (currentLocationMarker) {
        map.removeLayer(currentLocationMarker);
      }
      
      // Show current location with accuracy circle
      currentLocationMarker = L.circle(latlng, {
        radius: Math.max(accuracy, 3),
        color: accuracy <= 10 ? '#27ae60' : accuracy <= 20 ? '#f39c12' : '#e74c3c',
        fillColor: accuracy <= 10 ? '#d5f4e6' : accuracy <= 20 ? '#ffeaa7' : '#ffcdd2',
        fillOpacity: 0.3,
        weight: 2
      }).addTo(map);

      // Add center dot
      L.circleMarker(latlng, {
        radius: 4,
        color: 'white',
        fillColor: '#3498db',
        fillOpacity: 1,
        weight: 2
      }).addTo(currentLocationMarker);
    }

    function addPoint(latlng, accuracy) {
      if (!isTracking) return;

      console.log(`GPS Update - Lat: ${latlng.lat}, Lng: ${latlng.lng}, Accuracy: ${accuracy}m`);

      // Skip points with poor accuracy
      if (accuracy > MAX_ACCURACY) {
        console.log('Skipped point - poor accuracy');
        return;
      }

      // For the first point, always add it
      if (pathPoints.length === 0) {
        pathPoints.push(latlng);
        lastAddedPoint = latlng;
        
        // Create START marker
        const startMarker = L.circleMarker(latlng, {
          radius: 8,
          color: 'white',
          fillColor: '#e74c3c',
          fillOpacity: 0.9,
          weight: 3
        }).addTo(map);
        
        startMarker.bindTooltip('START', {
          permanent: true,
          direction: 'top',
          offset: [0, -15],
          className: 'start-tooltip'
        });
        
        pointMarkers.push(startMarker);
        
        // Center map on first location
        map.setView(latlng, 18);
        firstLocation = false;
        
        console.log('Added START point');
        updateStatus();
        return;
      }

      // Check minimum distance from last point
      if (lastAddedPoint) {
        const distance = getDistance(
          lastAddedPoint.lat, lastAddedPoint.lng,
          latlng.lat, latlng.lng
        );
        
        if (distance < MIN_DISTANCE) {
          console.log(`Skipped point - too close (${distance.toFixed(1)}m)`);
          return;
        }
        
        totalDistance += distance;
      }

      // Add the point
      pathPoints.push(latlng);
      lastAddedPoint = latlng;

      // Create point marker
      const marker = L.circleMarker(latlng, {
        radius: 6,
        color: 'white',
        fillColor: '#27ae60',
        fillOpacity: 0.9,
        weight: 2
      }).addTo(map);
      
      marker.bindTooltip(`${pathPoints.length}`, {
        permanent: true,
        direction: 'top',
        offset: [0, -10],
        className: 'point-tooltip'
      });
      
      pointMarkers.push(marker);

      console.log(`Added point ${pathPoints.length}`);
      
      drawPath();
      updateStatus();
      
      // Enable close button when we have enough points
      if (pathPoints.length >= 3) {
        closeBtn.disabled = false;
      }
    }

    function drawPath() {
      // Remove existing path
      if (polylineLayer) {
        map.removeLayer(polylineLayer);
      }

      if (pathPoints.length >= 2) {
        // Draw the walking path
        polylineLayer = L.polyline(pathPoints, {
          color: '#3498db',
          weight: 4,
          opacity: 0.8,
          dashArray: '10, 5'
        }).addTo(map);

        console.log(`Drew path with ${pathPoints.length} points`);
        
        // Keep the current location visible by adjusting map bounds
        if (pathPoints.length > 1) {
          const group = new L.featureGroup(pointMarkers);
          if (currentLocationMarker) {
            group.addLayer(currentLocationMarker);
          }
          map.fitBounds(group.getBounds().pad(0.1));
        }
      }
    }

    function drawFinalPolygon() {
      // Remove path line
      if (polylineLayer) {
        map.removeLayer(polylineLayer);
      }
      // Remove existing polygon
      if (polygonLayer) {
        map.removeLayer(polygonLayer);
      }

      if (pathPoints.length >= 3) {
        // Create final polygon
        polygonLayer = L.polygon(pathPoints, {
          color: '#27ae60',
          weight: 4,
          fillColor: '#d5f4e6',
          fillOpacity: 0.4
        }).addTo(map);
        
        calculateArea();
        
        // Fit map to show entire polygon
        map.fitBounds(polygonLayer.getBounds(), { padding: [20, 20] });
        
        console.log('Drew final polygon');
      }
    }

    function calculateArea() {
      if (pathPoints.length < 3) {
        console.log('Cannot calculate area - less than 3 points');
        return;
      }

      try {
        // Convert to turf format
        const coords = pathPoints.map(p => [p.lng, p.lat]);
        
        // Ensure polygon is closed
        if (coords[0][0] !== coords[coords.length-1][0] || coords[0][1] !== coords[coords.length-1][1]) {
          coords.push([pathPoints[0].lng, pathPoints[0].lat]);
        }

        // Calculate area and perimeter
        const polygon = turf.polygon([coords]);
        const areaSqm = turf.area(polygon);
        const areaAcres = areaSqm * 0.000247105;
        const areaHectares = areaSqm * 0.0001;
        const perimeterMeters = turf.length(turf.lineString(coords), { units: 'meters' });
        const perimeterKm = perimeterMeters / 1000;

        // Update display
        areaSqmDisplay.innerText = areaSqm.toLocaleString(undefined, {maximumFractionDigits: 2});
        areaAcresDisplay.innerText = areaAcres.toFixed(4);
        areaHectaresDisplay.innerText = areaHectares.toFixed(4);
        perimeterDisplay.innerText = perimeterMeters.toFixed(0);
        perimeterKmDisplay.innerText = perimeterKm.toFixed(3);

        console.log(`Area calculated: ${areaSqm.toFixed(2)} m¬≤`);
      } catch (error) {
        console.error('Error calculating area:', error);
        alert('Error calculating area. Please try again.');
      }
    }

    function startTracking() {
      if (!navigator.geolocation) {
        alert('‚ùå GPS is not available on your device.');
        return;
      }

      console.log('Starting GPS tracking...');

      // Reset everything
      isTracking = true;
      startTime = Date.now();
      totalDistance = 0;
      lastAddedPoint = null;
      firstLocation = true;
      
      // Update button states
      startBtn.disabled = true;
      stopBtn.disabled = false;
      closeBtn.disabled = true;

      // Start GPS tracking
      watchId = navigator.geolocation.watchPosition(
        position => {
          const { latitude, longitude, accuracy } = position.coords;
          const latlng = L.latLng(latitude, longitude);
          
          console.log(`GPS position: ${latitude}, ${longitude}, accuracy: ${accuracy}m`);
          
          // Always update current location indicator
          updateCurrentLocation(latlng, accuracy);
          
          // Try to add point
          addPoint(latlng, accuracy);
        },
        error => {
          console.error('GPS Error:', error);
          alert(`‚ùå GPS Error: ${error.message}\nPlease check your location permissions.`);
        },
        {
          enableHighAccuracy: true,
          maximumAge: 2000,
          timeout: 15000
        }
      );

      updateStatus();
    }

    function stopTrackingAndCalculate() {
      console.log('Stopping tracking and calculating...');
      
      // Stop GPS tracking
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      
      // Remove current location marker
      if (currentLocationMarker) {
        map.removeLayer(currentLocationMarker);
        currentLocationMarker = null;
      }

      isTracking = false;
      
      // Update button states
      startBtn.disabled = false;
      stopBtn.disabled = true;
      closeBtn.disabled = true;

      if (pathPoints.length < 3) {
        alert('‚ùå Need at least 3 points to calculate area. You have ' + pathPoints.length + ' points.');
        return;
      }

      drawFinalPolygon();
      updateStatus();
      
      // Show results
      setTimeout(() => {
        const areaText = areaSqmDisplay.innerText;
        const acresText = areaAcresDisplay.innerText;
        const perimeterText = perimeterDisplay.innerText;
        alert(`‚úÖ Area calculation complete!\nüìè Area: ${areaText} m¬≤ (${acresText} acres)\nüîÑ Perimeter: ${perimeterText} meters`);
      }, 500);
    }

    function closeShape() {
      console.log('Closing shape...');
      
      if (pathPoints.length < 3) {
        alert('‚ùå Need at least 3 points to close the shape. You have ' + pathPoints.length + ' points.');
        return;
      }

      // Stop GPS tracking
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      
      // Remove current location marker
      if (currentLocationMarker) {
        map.removeLayer(currentLocationMarker);
        currentLocationMarker = null;
      }

      isTracking = false;
      
      // Update button states
      startBtn.disabled = false;
      stopBtn.disabled = true;
      closeBtn.disabled = true;

      drawFinalPolygon();
      updateStatus();

      // Show results
      setTimeout(() => {
        const areaText = areaSqmDisplay.innerText;
        const acresText = areaAcresDisplay.innerText;
        const perimeterText = perimeterDisplay.innerText;
        alert(`‚úÖ Shape closed and area calculated!\nüìè Area: ${areaText} m¬≤ (${acresText} acres)\nüîÑ Perimeter: ${perimeterText} meters`);
      }, 500);
    }

    function clearAll() {
      console.log('Clearing all...');
      
      // Stop GPS tracking
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      
      // Reset variables
      isTracking = false;
      pathPoints = [];
      totalDistance = 0;
      startTime = null;
      lastAddedPoint = null;
      firstLocation = true;

      // Remove all layers
      [polylineLayer, polygonLayer, currentLocationMarker].forEach(layer => {
        if (layer) map.removeLayer(layer);
      });
      polylineLayer = polygonLayer = currentLocationMarker = null;

      // Remove all point markers
      pointMarkers.forEach(marker => map.removeLayer(marker));
      pointMarkers = [];

      // Reset display
      areaSqmDisplay.innerText = "0";
      areaAcresDisplay.innerText = "0";
      areaHectaresDisplay.innerText = "0";
      perimeterDisplay.innerText = "0";
      perimeterKmDisplay.innerText = "0";
      
      // Reset buttons
      startBtn.disabled = false;
      stopBtn.disabled = true;
      closeBtn.disabled = true;
      
      updateStatus();
    }

    // Event listeners
    startBtn.addEventListener('click', startTracking);
    stopBtn.addEventListener('click', stopTrackingAndCalculate);
    closeBtn.addEventListener('click', closeShape);
    clearBtn.addEventListener('click', clearAll);

    // Initialize
    updateStatus();
    console.log('Land Area Calculator initialized');
  </script>

</body>
</html>
